# DisMLec9

Created: September 29, 2024 8:55 PM
Class: COMP6005
Reviewed: Yes

### Discrete Mathematical Models

### Lecture 9

### Kane Townsend

### Semester 2, 2024

---

### Representing Positives, Negatives, and Zero

### Basic Representation

- **Binary Representation**: Use `+` or `-`in front of the integer.
    - Example:
        - `$+(1101)_2$` represents `$(13)_10$`
        - `$(1101)_2$` represents `$(-13)_10$`

### Naive Approach朴素方法

- **Extra Sign Bit**: Fix a number of bits per integer, using the left-most bit as the sign bit.
    - `0` for positive numbers
    - `1` for negative numbers
    - Example with a byte (8 bits):
        - `$(00001101)_2$` represents `$(13)_10$`
        - `$(10001101)_2$` represents `$(-13)_10$`
        - Both `$(00000000)_2$` and `$(10000000)_2$` represent zero
- **Drawbacks**: This method is not commonly used.

### Two's Complement

- **Improved Method**: Use an extra sign bit, but represent negatives using two's complement.
    - **Process**:
        - Fix `t` bits for each integer.
        - If the left-most bit (`d1`) is `0`, interpret as positive.
        - If `d1` is `1`, interpret as negative using: `$(d2d3...dt)_2 - 2^(t-1)$`
        - Toggle all bits and add one to find the negative.
        
        好的，我来为您解释二进制补码（Two's Complement）的概念：
        
        - 二进制补码是一种改进的负数表示方法，它使用额外的符号位来表示负数。
        - 基本过程如下：
            - 1. 固定使用t位来表示每个整数。
            - 2. 如果最左边的位（d1）是0，则解释为正数。
            - 3. 如果d1是1，则解释为负数。
            - 4. 要找到一个数的负数，需要翻转所有位，然后加1。
        
        这种方法相比于简单地使用符号位有几个优点：
        
        1. 只有一种零的表示方法（避免了正零和负零）。
        2. 简化了加法和减法运算。
        3. 可以表示比简单符号位方法更大范围的负数。
        
        二进制补码是现代计算机系统中广泛使用的整数表示方法，因为它简化了算术运算并提高了效率。
        

---

### Examples

### 4-bit Signed Integers

- **Binary to Decimal Mapping**:
    
    ```
    0000 -> 0
    0001 -> 1
    0010 -> 2
    0011 -> 3
    0100 -> 4
    0101 -> 5
    0110 -> 6
    0111 -> 7
    1000 -> -8
    1001 -> -7
    1010 -> -6
    1011 -> -5
    1100 -> -4
    1101 -> -3
    1110 -> -2
    1111 -> -1
    倒序表达做减法
    ```
    

### Example Calculation

- **Convert `1101` (4-bit signed integer) to Decimal**:
    - Since `d1 = 1`, it's negative.
    - Drop `d1`: `101`
    - Toggle bits: `010`
    - Add one: `011`
    - Convert to decimal: `3`
    - Multiply by `1`: `3`

### 8-bit Signed Integers

- **Binary to Decimal Mapping**:
    
    ```
    00000000 -> 0
    00000001 -> 1
    ...
    01111111 -> 127
    10000000 -> -128
    10000001 -> -127
    ...
    11111111 -> -1
    
    ```
    

### Example Calculation

- **Convert `10110101` (8-bit signed integer) to Decimal**:
    - Since `d1 = 1`, it's negative.
    - Drop `d1`: `0110101`
    - Toggle bits: `1001010`
    - Add one: `1001011`
    - Convert to decimal: `75`
    - Multiply by `1`: `75`

---

### Comparison of Approaches

### Naive Approach

- **Range**: `{-127, -126, ..., 127}`
- **Zero Representation**: `00000000` and `10000000`
- **Complex Addition/Subtraction**

### Two's Complement Approach

- **Range**: `{-128, -127, ..., 127}`
- **Zero Representation**: `00000000`
- **Simplified Operations**: Addition and subtraction are straightforward.

---

### Binary Arithmetic

### Adding 1-bit Numbers

- **Half Adder 半加法器**: A circuit with 2 bits in, 2 bits out.
    - Input: `p`, `q`
    - Output: `p + q`
    - Example:
        
        ```
        p q | p+q
        ----|----
        1 1 | 0
        1 0 | 1
        0 1 | 1
        0 0 | 0
        
        ```
        
    
    半加法器是一种基本的数字电路组件，用于执行两个单比特二进制数的加法运算。以下是半加法器的主要特点：
    
    - 输入：两个1位二进制数（p和q）
    - 输出：两位，表示p + q的结果
    - 功能：执行不带进位的1位二进制加法
    
    半加法器的真值表如下：
    
    ```
    p q | p+q
    ----|----
    1 1 | 0 1 右边进一位
    1 0 | 1 0
    0 1 | 1 0
    0 0 | 0 0
    ```
    
    这个真值表展示了半加法器的所有可能输入组合及其对应的输出。
    
    半加法器是构建更复杂数字电路（如全加法器）的基础组件，在计算机硬件设计中扮演着重要角色。
    

### Adding 1-bit Numbers with Carry（进位）

- **Full Adder 全加法器**: A circuit with 3 bits in, 2 bits out.
    - Input: `p`, `q`, `r`
    - Output: `p + q + r`
    - Example:
        
        ```
        p q r | p+q+r
        ------|------
        1 1 1 | 1 1
        1 1 0 | 1 0
        1 0 1 | 1 0
        1 0 0 | 0 1
        0 1 1 | 1 0
        0 1 0 | 0 1
        0 0 1 | 0 1
        0 0 0 | 0 0
        
        ```
        
    
    全加法器是一种数字电路组件，用于执行三个1位二进制数的加法运算。以下是全加法器的主要特点：
    
    1. 输入：三个1位二进制数（p、q和r）
    2. 输出：两位，表示p + q + r的结果
    3. 功能：执行带进位的1位二进制加法
    
    全加法器的真值表如下：
    
    ```
    p q r | p+q+r
    ------|------
    1 1 1 | 1 1
    1 1 0 | 1 0
    1 0 1 | 1 0
    1 0 0 | 0 1
    0 1 1 | 1 0
    0 1 0 | 0 1
    0 0 1 | 0 1
    0 0 0 | 0 0
    ```
    
    这个真值表展示了全加法器的所有可能输入组合及其对应的输出。全加法器是构建更复杂数字电路（如多位加法器）的基础组件，在计算机硬件设计中扮演着重要角色。它可以处理来自低位的进位，使得多位数的加法成为可能。
    

### 4-bit Addition via Full Adders

- **Cascade of Full Adders**: Chain multiple full adders to add multi-bit numbers.

好的，我来为您解释并展示4位全加法器的级联：

4位加法器通过级联多个全加法器来实现。这种方法允许我们对多位二进制数进行加法运算。以下是关键点：

- **级联全加法器**：将多个全加法器串联在一起，以处理多位数的加法

工作原理：

1. 每个全加法器处理一个位的加法
2. 低位的进位输出连接到高位的进位输入
3. 这种链式结构允许进位信息从低位传递到高位

优点：

- 可以处理任意位数的二进制加法
- 结构模块化，易于扩展
- 硬件实现相对简单

这种方法是计算机硬件设计中实现多位加法的基础，为更复杂的算术运算提供了基础。

### Integer Subtraction减法

- **Subtraction as Addition**: Convert `y` to `y` using two's complement, then add.
    - **Steps**:
        - Toggle all bits of `y`
        - Add one
        - Use existing addition circuits
        
        好的，我来为您解释一下整数减法的概念：
        
        整数减法（Integer Subtraction）在计算机中是通过将减法转换为加法来实现的。这种方法利用了二进制补码的特性，使得减法运算可以使用现有的加法电路来完成。以下是具体步骤：
        
        - **将减法转换为加法**：我们将 y 转换为 -y，然后进行加法运算。这是通过使用二进制补码来实现的。
        
        具体步骤如下：
        
        1. 将 y 的所有位取反（0变1，1变0）
        2. 对取反后的结果加1
        3. 使用现有的加法电路进行计算
        
        这种方法的优点是它允许我们使用相同的硬件电路来执行加法和减法操作，简化了计算机的硬件设计。
        
        通过这种方式，计算机可以高效地执行整数减法运算，而不需要专门的减法电路。
        

### Multiplication 直接乘就完事儿了

- **Binary Multiplication**: Use shifts and additions.
    - Example:
        
        ```
         	 1011
          ×1100
        -----
           0000
          00000
         101100
        1011000
        --------
        10000100
        
        ```
        

---

### Algorithms

### Binary Addition Algorithm

- **Input**: Two `n`bit numbers `p` and `q`
- **Output**: Sum `s` with `n+1` bits
- **Method**:
    1. Initialize `j = 0`, `c = 0`.
    2. Loop until `j = n+1`:
        - Add `j`th bits of `p` and `q` plus `c`
        - Store result bit in `s`
        - Update carry `c`
        - Increment `j`
        
        好的，我来为您解释二进制加法算法：
        
        二进制加法算法是用于计算两个二进制数之和的方法。以下是算法的主要步骤：
        
        - **输入**：两个n位二进制数p和q
        - **输出**：一个(n+1)位的和s
        - **方法**：
            1. 初始化 j = 0，c = 0（c是进位）
            2. 循环直到j = n+1：
                - 将p和q的第j位相加，再加上进位c
                - 将结果的最低位存储在s的第j位
                - 更新进位c（如果相加结果大于1，则c = 1，否则c = 0）
                - j增加1
        
        这个算法模拟了我们手动进行二进制加法的过程，从最低位开始，逐位相加，并处理进位。它能有效地处理任意长度的二进制数相加。
        

### Binary Multiplication Algorithm

- **Input**: Two `n`bit numbers `x` and `y`
- **Output**: Product `p` with `2n` bits

- **Method**:
    1. Initialize `j = 0`, `p = 0`
    2. Loop until `j = n`:
        - If `j`th bit of `y` is `1`, add `x` to `p`
        - Shift `x`
        - Increment `j`

---

### Examples

### Binary Addition

- **Example**: Add `0110` and `1111`
    - Result: `10101`

### Binary Multiplication

- **Example**: Multiply `1111` by `0110`
    - Result: `10000110`

---

This structured breakdown provides a clear and detailed representation of the lecture content, making it easier to understand and study the key concepts.