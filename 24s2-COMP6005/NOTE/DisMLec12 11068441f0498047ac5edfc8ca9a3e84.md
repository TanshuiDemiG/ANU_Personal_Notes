# DisMLec12

Created: September 29, 2024 8:56 PM
Class: COMP6005
Reviewed: Yes

### Discrete Mathematical Models

### Lecture 12

### Kane Townsend

### Semester 2, 2024

---

### Section B: Digital Information (cont.)

### Section B2: Sequences, Induction, Sorting (cont.)

---

### From Implicit 隐式 to Explicit 显式 Definitions: Example 4

**Objective:**

- Derive an explicit formula for investment capital from an implicit formula.

**Given:**

- Implicit formula:  $c_{n+1} = r \cdot c_n + d  \\ for all  n \in \mathbb{N}^*$
- Initial condition:  $c_0 = c$
- Parameters:  $r = 1.03 ,  d = -10 ,  c = 2 \times 10^4$

**Steps:**

1. **Generate the First Few Terms:**
    - $c_0 = c$
    - $c_1 = r \cdot c + d$
    - $c_2 = r \cdot (r \cdot c + d) + d = r^2 \cdot c + (r + 1) \cdot d$
    - $c_3 = r \cdot (r^2 \cdot c + (r + 1) \cdot d) + d = r^3 \cdot c + (r^2 + r + 1) \cdot d$
2. **Guess the General Form:**
    - $c_n = r^n \cdot c + (1 + r + r^2 + \cdots + r^{n-1}) \cdot d$
3. **Simplify Using the Geometric Series Sum Formula:**
    - Sum of geometric series:  $1 + r + r^2 + \cdots + r^{n-1} = \frac{1 - r^n}{1 - r}$
    - Explicit formula:  $c_n = r^n \cdot c + \frac{1 - r^n}{1 - r} \cdot d$
4. **Verification via Mathematical Induction:**
    - Verify the claim  $\forall n \in \mathbb{N}^*$
5. **Application:**
    - Calculate  $c_{10}$ :
        - $c_{10} = (1.03)^{10} (2 \times 10^4) + \frac{1 - (1.03)^{10}}{1 - 1.03} \cdot (-10)$
        - $c_{10} = 26878.33 - 114.64$
    - Conclusion: The $10 annual fee over 10 years costs the investment $114.64.
    
    这段内容是关于从隐式定义到显式定义的一个例子，特别是关于投资资本的计算。以下是主要内容的中文解释：
    
    **目标：**从隐式公式推导出投资资本的显式公式。
    
    **给定：**
    
    - 隐式公式（未显示具体内容）
    - 初始条件（未显示具体内容）
    - 参数（未显示具体内容）
    
    **步骤：**
    
    1. 生成前几项（具体内容未显示）
    2. 猜测通用形式
    3. 使用几何级数和公式简化
    4. 通过数学归纳法验证
    5. 应用：计算特定情况（具体内容未显示）
    
    **结论：**10年内每年10美元的费用会使投资损失114.64美元。
    
    这个例子展示了如何从一个隐式定义的序列推导出显式公式，并应用于实际的投资计算中。
    

---

### Mixed Sequences

混合序列是一种结合了几何序列和算术序列特性的序列。以下是对混合序列的详细解释：

**概括：**

- 混合几何-算术序列是一种特殊类型的序列，它在每一步都应用了几何和算术的变化。

**隐式定义：**

- 第一项通常给定（具体值未显示）
- 后续项的计算涉及乘法（几何部分）和加法（算术部分）

**显式定义：**

- 通常可以通过数学推导得到一个通用公式，但具体形式未给出

**示例：**

- 乘数：具体值未显示，但这是几何部分的比率
- 偏移量：2（这是每步添加的固定值，即算术部分）
- 第一项：1
- 计算第10项：具体计算未显示，但会使用给定的参数
- 稳定状态：随着n增大，序列趋近于4

这种混合序列在实际应用中很有用，例如在金融模型或增长模式中，既有百分比增长（几何部分）又有固定增加（算术部分）的情况。

**Generalization:**

- Mixed Geometric-Arithmetic Sequence

**Implicit Definition:**

- $a_k = a$  (first term)
- $a_{n+1} = r \cdot a_n + d  \\for all  n \geq k$

**Explicit Definition:**

- $a_n = a \cdot r^{n-k} + \frac{1 - r^{n-k}}{1 - r} \cdot d$

**Example:**

- Multiplier:  $\frac{1}{2}$
- Offset: 2
- First term: 1
- Calculate the 10th term:
    - $a_{10} = 1 \cdot (\frac{1}{2})^9 + \frac{1 - (\frac{1}{2})^9}{1 - \frac{1}{2}} \cdot 2 \approx 3.99$
    - Steady state: As  n  increases,  $a_n$  approaches 4.

---

### Counting Moves: Towers of Hanoi

**Rules:**

- Move only one disc at a time.
- Move discs that are at the top of the piles.
- No disc may sit on top of a smaller disc.

**Objective:**

- Calculate the number of moves for  n = 64  discs.

**Recursive Formula:**

- $x_{n+1} = 2 \cdot x_n + 1$

**Explicit Formula:**

- $x_n = 2^n - 1$

**Calculation:**

- $x_{64} = 2^{64} - 1 \approx 5.8 \times 10^{11}  seconds (~5.8 billion years).$

---

### Sorting Algorithms

**Definition:**

- Sorting algorithm: Procedure to sort a sequence into increasing order.

**Example:**

- Input:  $(x_n)_{n \in \{1, \ldots, 5\}} = \text{Jane, Fred, Jo, Jane, Ann}$
- Output:  $(y_n)_{n \in \{1, \ldots, 5\}} = \text{Ann, Fred, Jane, Jane, Jo}$

---

### Sorting Preliminaries

好的，我将为您解释"排序初步"（Sorting Preliminaries）这一部分的内容：

**索引集（Index Set）：**

- 这里应该给出了索引集的定义，但具体内容未显示。索引集通常用于表示排序算法中元素的位置。

**索引置换（Index Permutation）：**

- 定义为一个双射函数。
- 例子：π = ⎛ 3 4 5 6 ⎞
      ⎝ 6 4 3 5 ⎠
这个矩阵表示了一种排列方式，上行是原始位置，下行是新位置。

**重排序（Reordering）：**

- 定义了一个新序列 (y_n){s..t}，其中 y_n = x{π(n)}。这表示通过置换π来重新排列原序列。

这些概念是理解排序算法的基础。索引集定义了元素的位置，索引置换描述了元素如何被重新排列，而重排序则是应用这种置换的结果。这些概念为后续介绍具体排序算法奠定了基础。

**Index Set:**

- $I = \{i \in \mathbb{N}^* : s \leq i \leq f\}$

**Index Permutation:**

- Bijection  $\pi: I \to I$
- Example:  $\pi = \begin{pmatrix} 3 & 4 & 5 & 6 \\ 6 & 4 & 3 & 5 \end{pmatrix}$

**Reordering:**

- Sequence  ($y_n){s..t}$   *where  $y_n = x{\pi(n)}$*

---

### Least Element Algorithm

**Example:**

- Input sequence:  $(x_i)_{1..3} = (J, O, E)$
- Output:  $\pi(1) = 3, \pi(2) = 2, \pi(3) = 1$

**Algorithm:**

1. Initialization:  $i \leftarrow s + 1 ,  m \leftarrow s$ 
2. Loop: Compare and update marker  m 
3. Swap values of  $\pi(s)  and  \pi(m)$ 
4. 重复步骤1-3，直到整个序列完全排序。

最小元素算法的中文解释：

1. 初始化：设置一个标记，通常指向序列的第一个元素。
2. 循环比较：从标记位置开始，遍历剩余的未排序元素，比较并更新标记m，使其始终指向当前找到的最小元素。
3. 交换元素：将找到的最小元素与当前位置的元素交换。
4. 重复过程：重复步骤2-3，每次处理剩余的未排序部分，直到整个序列排序完成。

这个算法通过不断找出未排序部分的最小元素并将其放到已排序部分的末尾，逐步构建出一个有序序列。它简单直观，但对于大型数据集可能效率较低。

---

### Selection Sort Algorithm

**Example:**

- Input:  $(x_i)_{1..3} = (J, O, E)$
- Output:  $\pi = \begin{pmatrix} 3 & 1 & 2 \end{pmatrix}$

**Method:**

1. Initialization:  s $\leftarrow 1$ 
2. Loop: Run least element algorithm on  ($x_{\pi(i)})_{s..n}$ 
3. Repeat until sorted.

---

### Selection Sort: Number of Operations

**Operations:**

- Each iteration requires  n - s  comparisons.
- Total comparisons:  $T_n = \frac{n(n-1)}{2}$

---

### Other Sorting Algorithms

**Merge Sort:**

- Compare different sorting algorithms.
- Discuss advantages and disadvantages.
- Use a sub-algorithm for merging.

---

This structured format provides a clear and detailed overview of the lecture content, making it easier to understand and follow the key concepts and steps involved in the various topics covered.