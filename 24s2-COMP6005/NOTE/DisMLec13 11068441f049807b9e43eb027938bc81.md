# DisMLec13

Created: September 29, 2024 9:01 PM
Class: COMP6005
Reviewed: Yes

### Discrete Mathematical Models

### Lecture 13: Kane Townsend

### Semester 2, 2024

---

### Collaboration Statement for Assignment 1

- **Example Statement**:
    - The assignment I have submitted has been produced according to the rules on Page 1 of the MATH?005 Assignment 1.
    - The solutions produced have been written/typed on my own.
    - I have not used AI to prepare my solutions.
    - I have provided references to the sources I have used where appropriate.
    - **Student ID**: [Your Student ID]

---

## 1. Sorting (Cont.)

### Merge Algorithm

- **Definition**:
    - Takes two sequences in  S , already ordered according to some  $\leq$  and outputs an ordered sequence that merges the two input sequences.
- **Example**:
    - Merge $(x_i){1..2} = (1,4) and (y_j){1..3} = (2,3,5)$.
    - Steps:
        - Compare  $x_1 = 1  and  y_1 = 2$ . Since  1 < 2 , assign  z_1 = x_1 = 1 .
        - Compare  x_2 = 4  and  y_1 = 2 . Since  2 < 4 , assign  z_2 = y_1 = 2 .
        - Compare  x_2 = 4  and  y_2 = 3 . Since  3 < 4 , assign  z_3 = y_2 = 3 .
        - Compare  x_2 = 4  and  y_3 = 5 . Since  4 < 5 , assign  z_4 = x_2 = 4 .
        - No  x_3 , so assign  z_5 = y_3 = 5 .
    - Result: Merged list (1,2,3,4,5).
    - **中文解释**:
        - 合并算法是一种将两个已排序的序列合并成一个新的有序序列的方法。
        - 它通过比较两个输入序列的元素，按顺序选择较小（或较大）的元素放入新序列中。
        - 这个过程一直持续到所有元素都被放入新序列，最终得到一个完整的有序序列。
        - 合并算法是归并排序等高效排序算法的核心组成部分。
    - **合并算法的步骤解释**:
        - 1. **初始化**: 设置两个指针，分别指向两个输入序列的开始。同时，创建一个新的空序列用于存储合并结果。
        - 2. **比较元素**: 比较两个指针所指向的元素，选择较小（或较大，取决于排序顺序）的元素。
        - 3. **添加元素**: 将选中的元素添加到新序列的末尾。
        - 4. **移动指针**: 将选中元素所在序列的指针向后移动一位。
        - 5. **重复过程**: 重复步骤2-4，直到其中一个输入序列的所有元素都被添加到新序列中。
        - 6. **处理剩余元素**: 如果另一个序列还有剩余元素，将它们全部按顺序添加到新序列的末尾。
        - 7. **完成合并**: 当两个输入序列的所有元素都被处理后，合并过程结束，新序列即为最终的有序序列。

### Merge Algorithm: Pseudocode 伪代码

- **Input**:
    - Two lists (sequences) $(a_i){i \in \{1,...,n\}} \subseteq S and (b_j){j \in \{1,...,p\}} \subseteq S$ pre-sorted according to an ordering rule  $\leq$  on  S .
- **Output**:
    - In-order list (sorted sequence) $(z_k)_{k \in \{1,...,n+p\}}$ that merges the two input lists.
- **Method**:
    - Initialize indices:  $i, j, k \leftarrow 1 .$
    - Loop:
        - If  k = n + p + 1 , stop.
        - If  i = n + 1 , assign   $z_k \leftarrow b_j ,  j \leftarrow j + 1 .$
        - Else if  j = p + 1 , assign  $z_k \leftarrow a_i ,  i \leftarrow i + 1$ .
        - Else if  a_i < b_j , assign  $z_k \leftarrow a_i ,  i \leftarrow i + 1$ .
        - Else, assign  $z_k \leftarrow b_j ,  j \leftarrow j + 1$ .
        - $k \leftarrow k + 1$ .
    - Repeat loop.

### Merge Algorithm: Example of Execution

- **Example**:
    - Merge ($a_i$)*{1..3} = (1,3,7) and ($b_j$)*{1..5} = (2,3,6,8,9).
    - After each iteration:
        - (z_1, ..., z_k-1) :  (), (1), (1,2), (1,2,3), (1,2,3,3), (1,2,3,3,6), (1,2,3,3,6,7), (1,2,3,3,6,7,8), (1,2,3,3,6,7,8,9) .

## 2. Merge Sort Algorithm

- **Consider the sequence**: (4,2,3,1).
- **Steps**:
    - Apply merge algorithm for \{(4),(2)\} and \{(3),(1)\}.
    - Result: (2,4) and (1,3).
    - Apply merge algorithm on \{(2,4),(1,3)\}.
    - Result: (1,2,3,4).
    - 这个案例展示了归并排序的基本步骤：
    1. **分解**：将原始序列(4,2,3,1)分成两个子序列(4,2)和(3,1)。
    2. **排序**：对这两个子序列分别进行排序。
        - - (4,2)变成(2,4)
        - - (3,1)变成(1,3)
    3. **合并**：将排序后的子序列(2,4)和(1,3)合并成一个有序序列。
        - - 比较2和1，选择1
        - - 比较2和3，选择2
        - - 剩下3和4，按顺序放入
        - - 最终结果为(1,2,3,4)
    - 这个过程体现了归并排序的"分而治之"策略，通过递归地将问题分解为更小的子问题，然后将解决方案合并起来。
- **Explanation of Merge Sort Algorithm**:
    - Merge Sort is a divide-and-conquer algorithm that works by recursively breaking down a list into smaller sublists until each sublist consists of a single element, then merging those sublists back together to form a sorted list.
    - The key steps are:
        - 1. Divide the unsorted list into n sublists, each containing one element (a list of one element is considered sorted).
        - 2. Repeatedly merge sublists to produce new sorted sublists until there is only one sublist remaining. This will be the sorted list.
    - The merge process is the "compare-and-copy" operation that produces a sorted list from two smaller sorted lists.
    - Merge Sort is efficient for large data sets and has a time complexity of O(n log n) for all cases.

### Merge Sort Algorithm: Pseudocode

- **Input**:  $r \in \mathbb{N}, (x_n)_{n \in \{1,...,2^r\}} \subseteq S$ , and an ordering rule  $\leq  for  S$ .
- **Output**: In-order list (sorted sequence) $(z_n)_{n \in \{1,...,2^r\}}$ that is a rearrangement of the input list.
- **Method**: There are  r  steps.
    - If  r < 3 , adjust the description accordingly.
    - **Step 1**: Apply the Merge algorithm  2^r - 1  times with inputs $\{(x_1),(x_2)\}, \{(x_3),(x_4)\},..., \{(x_{2^r-1}),(x_{2^r})\}.$
        - Result:  2^r - 1  in-order lists of length 2.
    - **Step 2**: Apply the Merge algorithm  $2^{r-2}$  times with pairs of these lists as input.
        - Result:  $2^{r-2}$  in-order lists of length  $2 \times 2 = 2^2$ .
    - **Steps 3 to r**: Continue until you have just one  = 2^{r-r}  in-order list with  2^r  elements.
    
    好的，我会为您提供归并排序算法伪代码的中文解释：
    
    - **输入**：一个需要排序的列表和一个排序规则
    - **输出**：一个按顺序排列的列表，它是输入列表的重新排列
    - **方法**：算法包含 r 个步骤
        - 如果 r < 3，需要相应调整描述
        - **第1步**：应用合并算法 2^r - 1 次
            - 结果：得到 2^r - 1 个长度为2的有序列表
        - **第2步**：对这些列表的对应用合并算法
            - 结果：得到更长的有序列表
        - **第3步到第r步**：继续上述过程，直到得到一个包含 2^r 个元素的完整有序列表
    
    这个伪代码描述了归并排序的整体结构，它通过不断地将列表分割成更小的部分，然后再将这些部分合并成更大的有序列表，最终得到一个完全排序的列表。这种方法体现了"分而治之"的策略，是归并排序算法的核心思想。
    

### Merge Sort: Example

- **Example**: Merge sort (1,2,6,1,7,9,4,5).
- **Steps**:
    - **Step 1**:
        - $Merging \{(1),(2)\} gives (1,2).$
        - $Merging \{(6),(1)\} gives (1,6).$
        - $Merging \{(7),(9)\} gives (7,9).$
        - $Merging \{(4),(5)\} gives (4,5).$
    - **Step 2**:
        - Merging \{(1,2),(1,6)\} gives (1,1,2,6).
        - Merging \{(7,9),(4,5)\} gives (4,5,7,9).
    - **Step 3**:
        - Merging \{(1,1,2,6),(4,5,7,9)\} gives (1,1,2,4,5,6,7,9).

### Merge Sort: Counting Comparisons

- **Example**: Merge sort (1,2,6,1,7,9,4,5).
    - **Total Comparisons**: 15
    - Breakdown:
        - (1,2) : 1 comparison
        - (1,6) : 1 comparison
        - (7,9) : 1 comparison
        - (4,5) : 1 comparison
        - (1,1,2,6) : 5 comparisons
        - The 5 comparisons for merging (1,2) and (1,6) to form (1,1,2,6) can be broken down as follows:
            - 1. Compare 1 and 1 (first elements)
            - 2. Compare 2 and 1 (second element of first list with first element of second list)
            - 3. Compare 2 and 6 (second element of first list with second element of second list)
            - 4. Compare 2 and 6 again (to determine if 2 should be placed before 6)
            - 5. Final comparison to place 6 at the end
        - This process ensures that all elements are correctly positioned in the final merged sequence.
        - (4,5,7,9) : 2 comparisons
        - (1,1,2,4,5,6,7,9) : 6 comparisons
        - The 6 comparisons for merging (1,1,2,6) and (4,5,7,9) to form (1,1,2,4,5,6,7,9) can be broken down as follows:
            - 1. Compare 1 and 4 (first elements of both lists)
            - 2. Compare 1 and 4 (second element of first list with first element of second list)
            - 3. Compare 2 and 4 (third element of first list with first element of second list)
            - 4. Compare 6 and 4 (fourth element of first list with first element of second list)
            - 5. Compare 6 and 5 (fourth element of first list with second element of second list)
            - 6. Compare 6 and 7 (fourth element of first list with third element of second list)
        - This process ensures that all elements from both lists are compared and correctly positioned in the final merged sequence.

### Merge Sort: Number of Operations

- **Upper Bound**: Number of transfers
- **Definition**: Let  T_r  denote the number of transfers required to sort a sequence of length  2^r  using Merge sort.
    - $T_r = 2^r + 2T_{r-1} \forall r \in \mathbb{N} \setminus \{1\}$
    - $T_1 = 2$
- **Examples**:
    - $T_1$ = 2
    - $T_2$ = 2^2 + 4 = 8
    - $T_3$ = 2^3 + 2 \times 8 = 3 \times 2^3
    - $T_4$ = 2^4 + 2 \times (3 \times 2^3) = 4 \times 2^4
- **Claim**:  $\forall r \in \mathbb{N} T_r = r2^r$ . Verify by induction.

### Merge Sort and Selection Sort Compared

- **Merge Sort**:
    - Sorts a sequence of length  2^r  with at most  r2^r  comparisons.
- **Selection Sort**:
    - Uses  $\frac{2^r(2^r-1)}{2}$  comparisons.
- **Comparison**: Merge sort is much faster.
    - For  r = 10  (so  N = 1024 ):
        - **Merge sort**:  r2^r = 10240
        - **Selection sort**:  \frac{2^r(2^r-1)}{2} = 523776
- **Parallel Processing**:
    - Merge sort can be modified to work faster on machines with parallel processing capabilities.
    - Selection sort cannot be directly modified for parallel processing.
- **Programming Simplicity**:
    - Selection sort may be simpler to program, especially if indexing is required to avoid transfers of large blocks of data.

---

## B3: Matrices

### What is a Matrix?

- **Definition**:
    - Let  S  be a set, and  m, n \in \mathbb{N} .
    - An  m \times n  matrix (over  S ) is a rectangular array of members of  S , having  m  rows and  n  columns.
    - The array is enclosed with parentheses or brackets.
- **Examples**:
    - A = \begin{pmatrix} 1 & -2 & 3 \\ -4 & 5 & -6 \end{pmatrix}
        - A  is a  2 \times 3  matrix over  \mathbb{Z} .
    - B = \begin{pmatrix} \pi/2 \\ -\pi/2 \end{pmatrix}
        - B  is a  2 \times 1  matrix over  \mathbb{R} .
    - C = \begin{pmatrix} 1 & 52 & 52 & 5 \end{pmatrix}
        - C  is a  1 \times 3  matrix over  \mathbb{Q} .
- **Special Case**: Square matrices ( m = n ).
    - M \in M_n(S) .

### Indexing

- **Generic Member**:
    - $A = (a_{i,j}) = \begin{pmatrix} a_{1,1} & a_{1,2} & \cdots & a_{1,n} \\ a_{2,1} & a_{2,2} & \cdots & a_{2,n} \\ \vdots & \vdots & \ddots & \vdots \\ a_{m,1} & a_{m,2} & \cdots & a_{m,n} \end{pmatrix}$
    - a_{i,j} \in S  denotes the entry in row  i , column  j  of  A .
    - **Example**: For  A = \begin{pmatrix} 2 & 7 \\ 0 & -3 \end{pmatrix} :
        - a_{1,1} = 2 ,  a_{1,2} = 7 ,  a_{2,1} = 0 ,  a_{2,2} = -3 .

### Two Dimensional Information

- **1-Dimensional**:
    - Elements of  S^n = S \times S \times \cdots \times S  correspond to sequences (a_j)_{1..n}, i.e., functions  a: \{1, ..., n\} \rightarrow S .
- **2-Dimensional**:
    - Elements of  M_n(S)  correspond to functions  a: \{1, ..., n\} \times \{1, ..., n\} \rightarrow S .

### Examples

- **Image Representation**:
    - Let  C  be the set of colors.
    - A square 1 megapixel image is an element of  M_{10^3}(C) .
- **Relation Representation**:
    - A relation  $R \subseteq \{1, ..., n\} \times \{1, ..., n\}  can be represented by a matrix  (a_{i,j}) \in M_n(\{0,1\})  with  a_{i,j} = 1 \Leftrightarrow iRj$ .
    - **Example**:  $\begin{pmatrix} 0 & 0 & 1 & 1 \\ 0 & 1 & 1 & 0 \\ 0 & 0 & 0 & 1 \\ 0 & 0 & 0 & 1 \end{pmatrix}$

### Another Example

- **Weighted Relation**:
    - Let  $(a_{i,j}) \in M_n(\mathbb{Q})$  define a weighted relation.
    - **Example**: 4 companies,  1,2,3,4 , and let  $a_{i,j}$  be the money received by  i  from  j  in a year.
        - $\begin{pmatrix} 0 & 104 & 0 & 105 \\ 0 & 0 & 0 & 105 \\ 104 & 0 & 0 & 105 \\ 105 & 0 & 0 & 0 \end{pmatrix}$
        - Represents:
            - 1 received $104 from 2 and $105 from 4.
            - 2 received $105 from 4.
            - 3 received $104 from 1 and $105 from 4.
            - 4 received $105 from 1.

### Vectors and Vector Arithmetic

- **Definition**:
    - For any  $n \in \mathbb{N}$ , an element  $x = (x_1, ..., x_n) \in \mathbb{Q}_n$  is called a vector.
    - Can be viewed as:
        - Row vector:  $x \in M_{1 \times n}(\mathbb{Q})$
        - Column vector:  $x \in M_{n \times 1}(\mathbb{Q})$
- **Sum of Vectors**:
    - $x + y = (x_1, ..., x_n) + (y_1, ..., y_n) = (x_1 + y_1, ..., x_n + y_n)$ .
- **Scalar Product**:
    - $\forall \lambda \in \mathbb{Q} \lambda x = \lambda (x_1, ..., x_n) = (\lambda x_1, ..., \lambda x_n) .$

### Examples of Vectors and Vector Arithmetic

- **Ecosystem State**:
    - $p = (p_1, p_2, p_3) \in \mathbb{Q}_3$  represents the state of an ecosystem with  p_1, p_2, p_3  being the sizes of the populations of three different species.
    - If  p_1  increases by 10,  p_2  loses 20, and  p_3  gains 2, the new state is  p + c = (p_1, p_2, p_3) + (10, -20, 2) .
- **Harmonic Frequencies**:
    - $a = (a_1, ..., a_n) \in \mathbb{Q}_n$  represents the amplitudes  $a_k ,  1 \leq k \leq n ,$ of the harmonic frequencies  kf  of the fundamental frequency  f  of a note played on a violin.
    - 3a = 3(a_1, ..., a_n)  represents the same sound, but three times stronger.

---

### Next Lecture

- We will learn more about matrix arithmetic and see what type of processes can be modeled using matrices!