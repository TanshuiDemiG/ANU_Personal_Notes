# DisMLec26

Created: October 10, 2024 9:32 AM
Class: COMP6005
Reviewed: No

### Lecture 26: Key Topics and Expanded Explanations

---

### 1. **Dijkstra’s Algorithm (Revisited)**

This lecture revisits **Dijkstra’s Algorithm** with a new example involving a weighted directed graph (digraph). The algorithm still operates to find the shortest path in a graph where all edge weights are non-negative.

**Steps Recap**:

1. Mark the start node with a tentative distance of zero, and all other nodes with infinity.
2. Explore each neighbor of the current node, updating their tentative distances if a shorter path is found.
3. Mark the current node as visited once all its neighbors are processed.
4. Move to the unvisited node with the smallest tentative distance and repeat the process.

The modified graph in this lecture adjusts the weights and paths, ensuring understanding of how changes in graph structure affect Dijkstra’s operations.

这段文字讨论了Dijkstra算法的重新审视。以下是主要内容的中文解释：

- 本讲座重新探讨了Dijkstra算法，使用了一个带权重的有向图（digraph）作为新例子。
- 该算法仍然用于在所有边权重非负的图中寻找最短路径。
- 算法步骤回顾：
1. 将起始节点的暂定距离标记为零，其他所有节点标记为无穷大。
2. 探索当前节点的每个邻居，如果找到更短的路径就更新它们的暂定距离。
3. 处理完所有邻居后，将当前节点标记为已访问。
4. 移动到暂定距离最小的未访问节点，重复该过程。

本讲座中修改了图的权重和路径，以确保学生理解图结构的变化如何影响Dijkstra算法的运作。

---

### 2. **Weighted Digraphs**

A **weighted digraph** is a directed graph where each edge has an associated non-negative weight. In a digraph:

- The direction of edges matters (from one vertex to another), unlike in an undirected graph.
- Weights can represent various real-world costs, such as distance, time, or capacity.

Formally, a **weighted digraph** is defined as G with a weight function:

$\text{weight}: E(G) \rightarrow \mathbb{Q}^+$

where E(G) represents the set of edges and $\mathbb{Q}^+$ the non-negative rational numbers.

---

### 3. **Transport Networks**

A **transport network** is a specific kind of weighted digraph where the vertices and edges represent a system for transporting something (like goods, data, or fluid).

**Key Features**:

- **Source (s)**: The starting point from which flow begins.
- **Sink (t)**: The endpoint where flow is collected.
- **Capacities**: Weights on edges represent the maximum possible flow (or capacity) through that edge.
    - The edges are weighted with positive weights, called capacities.

**Example Network**:

```css
css
复制代码
  s → a → b → t
     ↘   ↗   ↘
        c

```

- This digraph models the flow from source s to sink t, where intermediate nodes a, b, and c act as passage points.
    
    

---

### 4. **Flows in Transport Networks**

The **flow** function FFF defines the actual amount of a substance (e.g., water, data) moving through the network. The flow must satisfy several constraints:

1. **Capacity Constraint**: F(e)≤C(e), where C(e) is the capacity of edge e and F(e) is the current flow.
    
    $F(e) \leq C(e)$
    
2. **Flow Conservation**: For every vertex (except s and t), the total flow into a vertex must equal the total flow out:
    
    

 $\sum_{e \in \text{in}(v)} F(e) = \sum_{e \in \text{out}(v)} F(e)$

This rule ensures no flow is lost or gained within the network.

以下是对选定部分"流在运输网络中"的中文解释：

**流在运输网络中**

1. **流函数**：流函数 F 定义了实际通过网络的物质（如水或数据）的数量。
2. **流的约束条件**：
- **容量约束**：F(e) ≤ C(e)，其中 C(e) 是边 e 的容量，F(e) 是当前流量。
- **流量守恒**：对于每个顶点（除了源点 s 和汇点 t），流入的总量必须等于流出的总量。这确保了网络内部不会有流量的损失或增加。

这些约束条件确保了流在网络中的合理分配和传输。

---

### 5. **Finding a Maximum Flow**

The **maximum flow** is the largest possible flow from s to t, adhering to all constraints. Finding this flow involves iterative improvements to the current flow until no more increases are possible.

**Process**:

1. Start with an initial flow F0​ (typically zero).
2. At each stage i, find an augmenting path pi​ (a path from s to t where more flow can be added).
3. Add an incremental flow along pi​ until no more augmenting paths can be found, leading to the maximum flow Fmax​.
    
    pip_i
    
    FmaxF_{\text{max}}
    

**Mathematical Notation**:
For each incremental stage:

$F_i = F_{i-1} + f_i$

where $f_i$  is the flow added along the augmenting path at stage i.

以下是对"寻找最大流"部分的中文解释：

**寻找最大流**

- **最大流**是从源点s到汇点t的最大可能流量，同时遵守所有约束条件。找到这个流量涉及对当前流量进行迭代改进，直到无法再增加为止。

**过程**：

1. 从初始流F0开始（通常为零）。
2. 在每个阶段i，找到一条增广路径pi（从s到t的可以增加流量的路径）。
3. 沿着pi增加流量，直到找不到更多的增广路径，最终得到最大流Fmax。

**数学表示**：
对于每个增量阶段：

Fi = Fi-1 + δi

其中δi是在第i阶段沿增广路径增加的流量。

这个过程通过不断寻找和利用增广路径来逐步提高网络中的流量，直到达到最大可能的流量。

---

### 6. **Spare Capacity**

**Spare capacity** S(e)of an edge is the difference between its capacity C(e) and the current flow F(e):

$S(e) = C(e) - F(e)$

Spare capacity helps identify which edges can still accommodate more flow.

---

### 7. **Vertex Labeling Algorithm for Maximum Flow**

To compute the maximum flow, a **vertex labeling algorithm** is used, which labels vertices iteratively to find augmenting paths.

**Steps**:

1. **Level assignment**: Vertices are assigned levels, starting from 0 at the source.
2. **Label propagation**: Propagate labels to the next vertices based on spare capacity, following a systematic order.
3. **Incremental flow**: Calculate the incremental flow along the path defined by labels.
4. Repeat the process until no more augmenting paths are found, at which point the current flow is the maximum flow.

**Example** (illustrative):

- Initial flow: F0​ is zero.
- Labels propagate from s to t, identifying a path.
- Add flow along this path to get F1​, repeat the process to find F2​,F3​,…,Fmax​.

---

This lecture builds on the foundational understanding of digraphs and flow networks, culminating in the **vertex labeling algorithm** for finding maximum flow. This algorithm is a systematic way of augmenting flow through a network until the capacity limits are reached.